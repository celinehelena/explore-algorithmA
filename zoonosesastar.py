# -*- coding: utf-8 -*-
"""ZoonosesAstar.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FvYiVCl54OJGBH-w_TJ9-9KfAiwCLdxa
"""

!pip install --upgrade osmnx
!pip install codecarbon

import pandas as pd
import networkx as nx
import osmnx as ox
import time
import matplotlib.pyplot as plt
import numpy as np
from sklearn.cluster import KMeans
from codecarbon import OfflineEmissionsTracker
import warnings

# Ignorar alguns avisos futuros do OSMnx que não são críticos
warnings.filterwarnings("ignore", category=FutureWarning)

def create_distance_matrix(graph, all_nodes):
    """
    Usa o algoritmo A* para pré-calcular a distância entre todos os pares de nós importantes.
    """
    dist_matrix = {}
    print(f"Pré-calculando a matriz de distâncias para {len(all_nodes)} nós...")
    node_pairs = [(u, v) for i, u in enumerate(all_nodes) for v in all_nodes[i:]]

    for u, v in node_pairs:
        try:
            distance = nx.astar_path_length(graph, u, v, weight='length')
            dist_matrix[(u, v)] = distance
            dist_matrix[(v, u)] = distance
        except (nx.NetworkXNoPath, nx.NodeNotFound):
            dist_matrix[(u, v)] = float('inf')
            dist_matrix[(v, u)] = float('inf')

    print("Matriz de distâncias criada.")
    return dist_matrix

def solve_tsp_nearest_neighbor(depot_node, point_nodes, dist_matrix):
    """
    Resolve o Problema do Caixeiro Viajante usando a heurística do "Vizinho mais próximo".
    """
    if not point_nodes:
        return [], 0
    unvisited = list(point_nodes)
    current_node = depot_node
    route = [depot_node]
    total_distance = 0
    while unvisited:
        next_node = min(unvisited, key=lambda node: dist_matrix.get((current_node, node), float('inf')))
        distance = dist_matrix.get((current_node, next_node), float('inf'))
        if distance == float('inf'):
            break
        total_distance += distance
        route.append(next_node)
        unvisited.remove(next_node)
        current_node = next_node
    total_distance += dist_matrix.get((current_node, depot_node), float('inf'))
    route.append(depot_node)
    return route, total_distance

def main():
    """
    Função principal para orquestrar a otimização de rotas.
    """
    print("Iniciando o processo de otimização de rotas...")
    start_time = time.time()

    depot_coords = (-5.7536678, -35.2627669) # (Latitude, Longitude)
    place_name = "Natal, Rio Grande do Norte, Brazil"

    try:
        points_df = pd.read_csv('centroid_filtered.csv')
        points_df = points_df.rename(columns={'Lat': 'latitude', 'Lon': 'longitude'})
        if 'latitude' not in points_df.columns or 'longitude' not in points_df.columns:
            raise ValueError("Falha ao renomear colunas. Verifique se 'Lat' e 'Lon' existem no CSV.")
    except FileNotFoundError:
        print("Erro: O arquivo 'centroid_filtered.csv' não foi encontrado.")
        return

    print("Baixando o mapa de ruas de Natal/RN...")
    G = ox.graph_from_place(place_name, network_type='drive')
    G_proj = ox.project_graph(G)
    print("Mapa baixado e projetado.")

    print("Mapeando coordenadas para os nós da malha viária...")
    depot_node = ox.nearest_nodes(G, depot_coords[1], depot_coords[0])
    point_nodes = ox.nearest_nodes(G, points_df['longitude'].values, points_df['latitude'].values)
    points_df['node'] = point_nodes

    print("Agrupando pontos de coleta para cada agente...")
    n_agents = 10
    kmeans = KMeans(n_clusters=n_agents, random_state=42, n_init=10)
    points_df['cluster'] = kmeans.fit_predict(points_df[['latitude', 'longitude']])

    # --- CORREÇÃO: LÓGICA DE BALANCEAMENTO ROBUSTA ---
    print("Balanceando os grupos para 5 agentes com 7 pontos e 5 com 6 pontos...")
    target_sizes = sorted([7] * 5 + [6] * 5, reverse=True)

    # Converte os clusters para uma lista de DataFrames
    clusters = [points_df[points_df['cluster'] == i].copy() for i in range(n_agents)]

    while True:
        # Ordena os clusters pelo tamanho atual, do maior para o menor
        clusters.sort(key=len, reverse=True)
        current_sizes = [len(c) for c in clusters]

        # Verifica se a distribuição atual corresponde à desejada
        if current_sizes == target_sizes:
            print("Balanceamento concluído com sucesso.")
            break

        # Encontra o cluster mais cheio (fonte) e o mais vazio (destino)
        source_cluster = clusters[0]
        dest_cluster = clusters[-1]

        # Acha o ponto no cluster fonte que está mais perto do centroide do cluster destino
        dest_centroid = dest_cluster[['latitude', 'longitude']].mean()
        points_to_move = source_cluster[['latitude', 'longitude']] - dest_centroid
        point_to_move_idx = np.linalg.norm(points_to_move.values, axis=1).argmin()
        point_id = source_cluster.index[point_to_move_idx]

        # Move o ponto
        point_row = source_cluster.loc[[point_id]]
        clusters[0] = source_cluster.drop(point_id) # Remove do cluster fonte
        clusters[-1] = pd.concat([dest_cluster, point_row]) # Adiciona ao cluster destino

    agent_assignments = [list(c['node']) for c in clusters]

    all_involved_nodes = list(set([depot_node] + list(point_nodes)))
    distance_matrix = create_distance_matrix(G_proj, all_involved_nodes)

    print("Calculando a rota para cada um dos 10 agentes...")
    all_routes_nodes, agent_distances = [], []
    for nodes in agent_assignments:
        route_nodes, distance = solve_tsp_nearest_neighbor(depot_node, nodes, distance_matrix)
        all_routes_nodes.append(route_nodes)
        agent_distances.append(distance)

    print("Gerando caminhos completos para visualização no mapa...")
    all_routes_for_plot = []
    for route in all_routes_nodes:
        if len(route) < 2: continue
        full_path = []
        try:
            for k in range(len(route) - 1):
                path_segment = nx.shortest_path(G_proj, route[k], route[k+1], weight='length')
                full_path.extend(path_segment[:-1])
            full_path.append(route[-1])
            all_routes_for_plot.append(full_path)
        except nx.NetworkXNoPath:
            print(f"Aviso: Não foi possível gerar o caminho de plotagem para a rota: {route}")

    execution_time = time.time() - start_time

    print("\n--- Relatório Final ---")
    for i, dist in enumerate(agent_distances):
        num_pontos = len(agent_assignments[i])
        print(f"Agente {i+1} ({num_pontos} pontos): Distância percorrida: {dist/1000:.2f} km")
    total_distance = sum(agent_distances)
    print(f"\nDistância total percorrida: {total_distance/1000:.2f} km")
    print(f"Tempo total de execução: {execution_time:.2f} segundos.")

    if all_routes_for_plot:
        print("\nGerando o mapa com as rotas...")
        route_colors = ox.plot.get_colors(n=len(all_routes_for_plot), cmap='tab10')
        fig, ax = ox.plot_graph_routes(
            G_proj, all_routes_for_plot, route_colors=route_colors, route_linewidth=2,
            node_size=0, bgcolor='#FFFFFF', show=False, close=False
        )

        depot_x, depot_y = G_proj.nodes[depot_node]['x'], G_proj.nodes[depot_node]['y']
        # Usa o DataFrame original para plotar todos os pontos iniciais
        points_x = points_df.loc[points_df['node'].isin(point_nodes), 'node'].apply(lambda n: G_proj.nodes[n]['x'])
        points_y = points_df.loc[points_df['node'].isin(point_nodes), 'node'].apply(lambda n: G_proj.nodes[n]['y'])

        ax.scatter(points_x, points_y, c='blue', s=40, marker='o', label='Pontos de Coleta', zorder=4)
        ax.scatter(depot_x, depot_y, c='black', s=200, marker='*', label='Centro de Zoonoses', zorder=5)

        legend_elements = [plt.Line2D([0], [0], color=route_colors[i], lw=4, label=f"Agente {i+1} ({len(agent_assignments[i])} pts): {agent_distances[i]/1000:.2f} km") for i in range(len(agent_assignments))]
        ax.legend(
            handles=legend_elements,
            title="Rotas dos Agentes",
            loc='upper left',
            bbox_to_anchor=(1.02, 1),
            borderaxespad=0.
        )

        ax.set_title("Rotas Otimizadas para Coleta de Amostras em Natal/RN", fontsize=16)
        plt.tight_layout(rect=[0, 0, 0.85, 1])
        plt.show()

if __name__ == '__main__':
    print("Inicializando o monitor de emissões em modo offline para o Brasil...")
    from codecarbon import OfflineEmissionsTracker
    tracker = OfflineEmissionsTracker(
        project_name="otimizacao_rotas_final",
        log_level='error',
        country_iso_code="BRA"
    )
    tracker.start()
    try:
        main()
    finally:
        emissions_result = tracker.stop()
        # emissions_result pode ser objeto ou float
        if hasattr(emissions_result, 'emissions'):
            co2_kg = emissions_result.emissions
            energy_kwh = getattr(emissions_result, 'energy_consumed', None)
        else:
            # se for float, já é kgCO2eq
            co2_kg = emissions_result
            energy_kwh = None
        print("Pegada de Carbono (CodeCarbon):")
        print(f"  - Emissões de CO2: {co2_kg:.6f} kg CO2eq")
        if energy_kwh is not None:
            print(f"  - Consumo de Energia: {energy_kwh:.6f} kWh")
        else:
            print("  - Consumo de Energia: não disponível")